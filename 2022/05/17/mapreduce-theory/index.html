<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>论文阅读——MapReduce——Simplifified Data Processing on Large Clusters | 扶摇之鹏</title><meta name="keywords" content="distributed system,MapReduce"><meta name="author" content="Smartog,2369398685@qq.com"><meta name="copyright" content="Smartog"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="MapReduce: Simplifified Data Processing on Large Clusters 论文链接 MapReduce整体介绍MapReduce是一个针对处理大数据集的编程模型，主要有Map函数和Reduce函数两个核心概念。我们使用Map函数来从输入文件中产生intermediate（这里翻译成“中间”） key&#x2F;value键值对，然后使用Reduce函数来合并所有属于">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读——MapReduce——Simplifified Data Processing on Large Clusters">
<meta property="og:url" content="http://example.com/2022/05/17/mapreduce-theory/index.html">
<meta property="og:site_name" content="扶摇之鹏">
<meta property="og:description" content="MapReduce: Simplifified Data Processing on Large Clusters 论文链接 MapReduce整体介绍MapReduce是一个针对处理大数据集的编程模型，主要有Map函数和Reduce函数两个核心概念。我们使用Map函数来从输入文件中产生intermediate（这里翻译成“中间”） key&#x2F;value键值对，然后使用Reduce函数来合并所有属于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2022-05-17T08:13:30.000Z">
<meta property="article:modified_time" content="2022-07-15T02:26:01.634Z">
<meta property="article:author" content="Smartog">
<meta property="article:tag" content="distributed system">
<meta property="article:tag" content="MapReduce">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/17/mapreduce-theory/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '论文阅读——MapReduce——Simplifified Data Processing on Large Clusters',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-15 10:26:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img-blog.csdnimg.cn/8f7b645dd13642308f79801772084d7c.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">扶摇之鹏</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">论文阅读——MapReduce——Simplifified Data Processing on Large Clusters</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-17T08:13:30.000Z" title="发表于 2022-05-17 16:13:30">2022-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-15T02:26:01.634Z" title="更新于 2022-07-15 10:26:01">2022-07-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/paper/">paper</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="论文阅读——MapReduce——Simplifified Data Processing on Large Clusters"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p><strong>MapReduce: Simplifified Data Processing on Large Clusters</strong> <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文链接</a></p>
<h3 id="MapReduce整体介绍"><a href="#MapReduce整体介绍" class="headerlink" title="MapReduce整体介绍"></a>MapReduce整体介绍</h3><p>MapReduce是一个针对处理大数据集的编程模型，主要有Map函数和Reduce函数两个核心概念。我们使用Map函数来从输入文件中产生intermediate（这里翻译成“中间”） key/value键值对，然后使用Reduce函数来合并所有属于相同key的value。</p>
<p>具体来说，用户编写Map函数接受原始key/value键值对，然后产生一系列的中间key/value，MapReduce会将属于同一个key的所有value聚合成value列表，然后将它们传给Reduce函数。用户编写的Reduce函数接收中间key以及属于该key的value列表，然后将属于同一个key的value合并输出。根据论文描述，intermediate value是通过迭代器的形式提供给Reduce函数的，这样做的目的是为了应对value列表太大，无法全部放入内存的情况。</p>
<p>以这种风格编写的程序会在大型机器集群上自动并行执行，其中，运行时系统负责以下工作：</p>
<ul>
<li>输入数据划分的相关细节</li>
<li>多机器上的任务调度</li>
<li>处理机器故障</li>
<li>管理集群内机器间的通信</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/961cb1a68acd42148044d185e117f324.png" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<h3 id="MapReduce实际部署与执行"><a href="#MapReduce实际部署与执行" class="headerlink" title="MapReduce实际部署与执行"></a>MapReduce实际部署与执行</h3><p>通过自动将输入数据划分成M份，Map函数的调用被分布到多台机器上。划分的M份数据可以在多台机器上并行处理。Reduce函数调用通过使用划分函数partition function，例如$hash(key)$将中间键划分为R份，划分的数量和划分函数由用户指定。</p>
<h4 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h4><p>上图是MapReduce执行的整个流程，当用户调用MapReduce函数时，将发生以下行为：</p>
<ul>
<li>1，用户程序中的MapReduce库首先将用户输入划分成M份，每一份的大小通常在16MB到64MB之间，可以由用户控制。然后将在集群机器上开启程序的多个副本。</li>
<li>2，副本中有一个特殊副本—master，剩下的是由master分配任务的workers。共有M个map任务和R个reduce任务需要划分。master会选择空闲的workers并为其分配一个map或者reduce任务。</li>
<li>3，被分配map任务的worker将读取对应的输入数据内容。它解析输入数据中的key/value对并将每一个对传输给用户定义的Map函数。由Map函数产生的中间key/value对将被缓存在内存中。</li>
<li>4，被缓存的键值对被周期性的写入磁盘，并由partition函数划分成R份，它们的磁盘地址将被传输给master，master随后负责将这些地址传输给reduce workers。</li>
<li>5，当一个reduce worker从master处获得上述中间key/value的磁盘地址，它将通过远程过程调用读取map workers磁盘上对应的中间键值对数据。读取完成后，reduce worker将对中间key/value进行排序以使得相同key的键值对可以被分到同一组。排序是需要的，因为很多不同的key会被映射到统一个reduce任务。如果中间键值对的数量太多以至于无法装入内存，将使用外部排序。</li>
<li>6，reduce worker将遍历排序后的键值对，对于每一个不同的key，将该key和其对应的value列表（由5中排序生成）传输给用户定义的Reduce函数。Reduce函数的输出将被附加到该reduce分区的最终输出文件中。</li>
<li>7，当所有的map任务和reduce任务全部完成，master唤醒用户程序，此刻MapReduce函数调用将返回到用户程序。</li>
</ul>
<p>当程序成功执行后，mapreduce的输出数据将保存在R份文件中，通常用户不需要将这R份文件合并成一份文件，通常这些文件将作为其他MapReduce的输入，或者通过其他支持处理分区文件的应用系统来使用这些文件。</p>
<h4 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h4><p>master中保存并维护了诸多数据结构，对于每一个map任务和reduce任务，master存储其状态如：$idel、in-progress、completed$，并且保存了处于非空闲状态的worker机器的标识。</p>
<p>中间文件的地址通过master从map任务传输到reduce任务，因此对于每一个已经完成的map任务，master存储其地址以及由map任务产生的R个中间文件区域的大小。当map任务完成时对这些信息进行更新，这些信息被逐步推送给拥有运行状态reduce任务的workers。</p>
<h4 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h4><p>由于MapReduce是为大规模机器集群设计的，因此机器故障必须被优雅地解决。</p>
<ul>
<li><p><strong>worker failure：</strong>master周期性地ping每一个worker，如果一定时间内master没有收到回复则将worker标记为故障。worker完成地map任务将被重设为空闲状态得以在其他worker上进行调度。一个failure worker上处于in-progress状态地map任务或者reduce任务也会被重设为空闲状态，有资格进行重调度。</p>
<p>处于failure状态的已完成的map任务需要被重新执行因为其输出文件被存储在故障机器的磁盘无法访问。处于failure状态的已完成的reduce任务不需要重执行，因为其输出保存在一个全局文件系统中。</p>
<p>当map任务起初在worker A执行但是由于A故障而后在worker B执行，所有正在执行reduce任务的worker都会被通知这次重执行。所有尚未从worker A读取数据的reduce任务将从worker B读取数据。</p>
</li>
<li><p><strong>master failure：</strong>通过周期性地将master中的数据结构写入checkpoint，当master挂掉，可以利用最新的checkpoint创建副本，但是考虑到只有一个master，一般不太可能让其失败。如果master失败，则停止MapReduce，客户端可以检查此状态并重试其定义的MapReduce操作。</p>
</li>
<li><p><strong>Semantics in the Presence of Failures：</strong>当用户提供的map和reduce运算符是确定性函数时，我们所实现的分布式系统在任何情况下的输出都和所有程序在没有任何错误、并且按照顺序生成的输出是一样的。</p>
<p>我们依赖于map任务和 reduce任务输出的原子性提交来实现这个特性。每个正在执行的任务会将它的输出写入到私有的临时文件中去。每个Reduce任务会生成这样一个文件，每个Map任务则会生成R个这样的文件（一个Reduce任务对应一个文件）。当一个map任务完成时，该map任务对应的worker会向master发送信息，该信息中包含了R个临时文件的名字。如果master从一个已经完成的map工作的worker处又收到这个完成信息，master就会将该信息忽略。否则，它会将这R个文件名记录在master的数据结构中。</p>
<p>当Reduce任务完成时，reduce worker会以原子的方式将临时输出文件重命名为最终输出文件。如果多台机器执行同一个reduce任务，那么对同一个输出文件会进行多次重命名。我们依赖于底层文件系统所提供的原子性重命名操作来保证最终的文件系统状态仅包含一个Reduce任务所产生的数据。</p>
<p>我们的map和reduce运算符绝大多数情况下是确定性的，在这种情况下我们的语义就代表了程序的执行顺序，这使得能够轻易地理解其程序的行为。当map 和reduce运算都是非确定性的情况下，我们会提供一种稍弱但依旧合理的语义。当在进行一个非确定性操作时，Reduce任务R1的输出等同于一个非确定性程序按顺序执行产生的输出。但是另一个Reduce任务R2的输出可能符合一个不同的非确定顺序程序执行产生的R2的输出。</p>
<p>(知秋注：输出的结果可以由A来处理，也可以由B来处理，比如A处理{a,b,c}，B处理{a，d，e}，现在map下发了一个a，那这个a既可以交由A，也可以交由B进行处理，又好比编译原理中的词法分析，if可以被identify处理，也可以被keywords处理，只不过我们在其中设定了优先级，那弱语义就变为了强语义)</p>
<p>考虑下这种情况，我们有一个Map任务M，两个Reduce任务，$R_1$和$R_2$。假设$e(R_i)$是$R_i$已经提交的执行过程（此处的e代表execution）（有且只有这样一次的提交）。当$e(R_1)$已经读取了由M产生的一次输出，并且$e(R_2)$读取了由M产生的另一次输出，这就会导致较弱语义的发生。</p>
<p>(知秋注:结合上一个注，如果map下发了两次a，第一次A处理了，第二次B处理了，这就是所谓的较弱语义的发生)。</p>
</li>
</ul>
<h4 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h4><p>GFS将每个文件划分为64MB的块，并在不同的机器上存储每个块的几个副本（通常是3个副本）。MapReduce主服务器会考虑到输入文件的位置信息，并尝试在包含相应输入数据副本的机器上调度映射任务。如果失败，它将试图在该任务的输入数据的副本附近调度一个映射任务（例如，在与包含该数据的机器在相同的网络交换机上的工作机器上）。</p>
<h4 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h4><p>如前所述，我们将映射阶段细分为M个，减少阶段细分为R。理想情况下，M和R应该远远大于工作机器的数量。让每个worker执行许多不同的任务可以改善动态负载平衡，并在worker失败时加速恢复：它已经完成的许多映射任务可以分散到所有其他worker机器上。在我们的实现中，对于M和R的大小有实际的界限，因为主服务器必须做出$O(M+R)$调度决策，并在内存中保持$O(M∗R)$状态。</p>
<p>在实践中，我们倾向于选择M使得每个单独的任务输入数据的大小为16MB到64MB（以便使得上述的局部性优化最有效），我们将R设置为使用的工作机器数量的小倍数。我们经常使用M=200,000，R=5,000，使用2,000台机器。</p>
<h4 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h4><p>由于单个机器可能存在磁盘损坏等因素从而延长整个MapReduce任务的执行时间，当一个MapReduce操作将要完成时，master为剩下的in-progress状态的任务启用备份执行，当原任务或者备份任务完成时将任务状态设置为完成。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上述描述对于大多数需求已经足够，但是论文仍然提出了一些有用的扩展。</p>
<h4 id="Partition-函数"><a href="#Partition-函数" class="headerlink" title="Partition 函数"></a>Partition 函数</h4><p>中间键值对通过partition函数被划分，默认的函数为$hash(key) mod R$，产生的划分也相对平衡。在一些特定应用中也可以采用不同的分区函数来更好的满足应用需求，例如有时输出中间键为URLs，我们希望含有相同hostname的URL出现在同一份输出文件中，则分区函数可以设置为:</p>
<script type="math/tex; mode=display">
hash(Hostname(urlkey))\ mod \ R</script><h4 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h4><p>在一个给定分区中的中间键值对将按照键的顺序进行处理，有助于在每个分区生成排序输出文件，文件按key排序有助于按键进行的随机查找。</p>
<h4 id="Combiner-函数"><a href="#Combiner-函数" class="headerlink" title="Combiner 函数"></a>Combiner 函数</h4><p>在某些情况下，由每个map任务生成的中间键可能存在大量重复，而用户指定的reduce函数与其相关联。例如在wordcount实例中map任务将产生大量的$<the,1>$键值对，所有的这些计数将通过网络传输到reduce任务然后通过reduce函数累加为一个数。我们允许用户指定一个Combiner函数，Combiner函数可以在键值对数据通过网络传输前进行对属于相同key的value进行部分合并操作。</p>
<p>Combiner函数是在执行map任务的机器上执行的，通常Combiner函数和Reduce函数的代码相同。唯一的区别在于MapReduce如何处理函数的输出。reduce函数的输出被写入最终的输出文件，combiner函数的输出将被写入中间文件，这些中间文件随后将被传输到reduce任务。</p>
<p>对于某些任务，combiner函数可以起到很好的加速作用。</p>
<h4 id="Input-and-Output-Types"><a href="#Input-and-Output-Types" class="headerlink" title="Input and Output Types"></a>Input and Output Types</h4><p>MapReduce支持多种不同形式的数据输入。用户可以自己实现Reader接口来添加输入数据类型。</p>
<h4 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side-effects"></a>Side-effects</h4><p>在某些情况下，MapReduce的用户发现从他们的map或者reduce任务中生成辅助文件作为额外的输出很方便。我们依靠应用程序编写者来使这种副作用成为原子的和幂等的。通常，应用程序会写入临时文件，并在文件完全生成后原子重命名。</p>
<h4 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h4><p>有时，一些特定记录导致的bug将使得整个MapReduce失败，有时忽略一些记录也是可以接受的，例如在大型数据集上进行统计分析。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录会导致确定性崩溃，并跳过这些记录，以便继续前进。</p>
<p>每个工作进程安装一个信号处理程序，以捕获分段违规和总线错误。在调用用户映射或减少操作之前，MapReduce库将参数的序列号存储在全局变量中。如果用户代码产生一个信号，信号处理程序向MapReduce主服务器发送一个包含序列号的“最后喘息”UDP包。当主服务器在特定记录上看到多个失败时，它表示在下次重新发出对应的“映射”任务或“减少”任务时，应跳过该记录。</p>
<h4 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h4><p>Map或Reduce函数中的调试问题可能很棘手，因为实际的计算发生在一个分布式系统中，通常发生在几千台机器上，并由主机动态地做出工作分配决策。为了帮助促进调试、分析和小规模测试，我们开发了MapReduce库的另一种实现，该实现可以在本地机器上依次执行MapReduce操作的所有工作。</p>
<h4 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h4><p>主服务器运行一个内部HTTP服务器，并导出一组状态页以供人类使用。状态页面显示计算的进度，如已经完成了多少任务、多少正在进行、输入的字节、中间数据的字节、输出的字节、处理速率等。这些页面还包含了链向标准错误信息和输出文件。用户可以利用这些数据来预测计算将花费多长时间以及是否应该为计算增加更多的资源。这些页面也可以被用来洞察何时计算比预期慢。</p>
<p>此外，顶级状态页面显示了哪些工人失败了，以及哪些工人映射并减少了他们在失败时正在处理的任务。当试图诊断用户代码中的错误时，此信息非常有用。</p>
<h4 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h4><p>MapReduce库提供了一个计数器工具来计算各种事件的发生次数。例如，用户代码可能希望计算已处理的单词总数或被索引的德语文档数。要使用此工具，用户代码将创建一个命名的计数器对象，然后在“Map/Reduce”函数中适当地递增计数器。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counter* uppercase;</span><br><span class="line">uppercase = GetCounter(<span class="string">&quot;uppercase&quot;</span>);</span><br><span class="line"></span><br><span class="line">map(String name, String contents):</span><br><span class="line">    <span class="keyword">for</span> each word w in contents:</span><br><span class="line">   	  <span class="keyword">if</span> (IsCapitalized(w)):</span><br><span class="line">        uppercase-&gt;Increment();</span><br><span class="line">      EmitIntermediate(w, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>来自单个工作机器的计数器值会定期传播到主服务器（可以包含在ping响应中）。主服务器聚合成功映射中的计数器值并减少任务，并在MapReduce操作完成后将它们返回给用户代码。当前计数器值也显示在主状态页面上，以便人类可以观察实时计算的进度。在聚合计数器值时，主会消除重复执行同一映射的影响，或减少任务以避免重复计数。</p>
<p>一些计数器值由MapReduce库自动维护，例如处理的输入键/值对的数量和产生的输出键/值对的数量。用户发现该计数器工具对完整性检查MapReduce操作的行为很有用。例如，在某些MapReduce操作中，用户代码可能希望确保产生的输出对的数量完全等于处理的输入对的数量，或者处理的德国文档的比例在处理的文档总数的一些可容忍的比例内。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Smartog</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/17/mapreduce-theory/">http://example.com/2022/05/17/mapreduce-theory/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">扶摇之鹏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/distributed-system/">distributed system</a><a class="post-meta__tags" href="/tags/MapReduce/">MapReduce</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/ShareJS/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/27/DDIA-Chapter3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DDIA Chapter 3：数据存储与检索</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/11/%E5%BC%80%E7%AB%AF/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">开端</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#MapReduce%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">MapReduce整体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapReduce%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">2.</span> <span class="toc-text">MapReduce实际部署与执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Execution-Overview"><span class="toc-number">2.1.</span> <span class="toc-text">Execution Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Master-Data-Structures"><span class="toc-number">2.2.</span> <span class="toc-text">Master Data Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fault-Tolerance"><span class="toc-number">2.3.</span> <span class="toc-text">Fault Tolerance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Locality"><span class="toc-number">2.4.</span> <span class="toc-text">Locality</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-Granularity"><span class="toc-number">2.5.</span> <span class="toc-text">Task Granularity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Backup-Tasks"><span class="toc-number">2.6.</span> <span class="toc-text">Backup Tasks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Partition-%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">Partition 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ordering-Guarantees"><span class="toc-number">3.2.</span> <span class="toc-text">Ordering Guarantees</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combiner-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">Combiner 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Input-and-Output-Types"><span class="toc-number">3.4.</span> <span class="toc-text">Input and Output Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Side-effects"><span class="toc-number">3.5.</span> <span class="toc-text">Side-effects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Skipping-Bad-Records"><span class="toc-number">3.6.</span> <span class="toc-text">Skipping Bad Records</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Local-Execution"><span class="toc-number">3.7.</span> <span class="toc-text">Local Execution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Status-Information"><span class="toc-number">3.8.</span> <span class="toc-text">Status Information</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Counters"><span class="toc-number">3.9.</span> <span class="toc-text">Counters</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Smartog</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = '/pluginsSrc/mathjax/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="/pluginsSrc/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>