<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>cmu15-445-3 Data Storage | 扶摇之鹏</title><meta name="keywords" content="database system"><meta name="author" content="Smartog,2369398685@qq.com"><meta name="copyright" content="Smartog"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="存储我们将重点关注一个“面向磁盘”的DBMS体系结构，该体系结构假设数据库的主存储位置位于非易失性磁盘上。 在存储层次结构的顶部，您有最接近CPU的设备。这是最快的存储空间，但它也是最小和最昂贵的。远离CPU越远，存储设备的容量就越大，但离CPU也越远。这些设备的每GB值也会更便宜。  Volatile Devices:  Volatile means that if you pull the p">
<meta property="og:type" content="article">
<meta property="og:title" content="cmu15-445-3 Data Storage">
<meta property="og:url" content="http://example.com/2022/07/14/cmu445-3/index.html">
<meta property="og:site_name" content="扶摇之鹏">
<meta property="og:description" content="存储我们将重点关注一个“面向磁盘”的DBMS体系结构，该体系结构假设数据库的主存储位置位于非易失性磁盘上。 在存储层次结构的顶部，您有最接近CPU的设备。这是最快的存储空间，但它也是最小和最昂贵的。远离CPU越远，存储设备的容量就越大，但离CPU也越远。这些设备的每GB值也会更便宜。  Volatile Devices:  Volatile means that if you pull the p">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2022-07-14T12:10:35.000Z">
<meta property="article:modified_time" content="2022-08-13T02:31:31.852Z">
<meta property="article:author" content="Smartog">
<meta property="article:tag" content="database system">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/14/cmu445-3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cmu15-445-3 Data Storage',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-13 10:31:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img-blog.csdnimg.cn/8f7b645dd13642308f79801772084d7c.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">扶摇之鹏</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">cmu15-445-3 Data Storage</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-14T12:10:35.000Z" title="发表于 2022-07-14 20:10:35">2022-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-13T02:31:31.852Z" title="更新于 2022-08-13 10:31:31">2022-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cmu15-445/">cmu15-445</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cmu15-445-3 Data Storage"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>我们将重点关注一个“面向磁盘”的DBMS体系结构，该体系结构假设数据库的主存储位置位于非易失性磁盘上。</p>
<p>在存储层次结构的顶部，您有最接近CPU的设备。这是最快的存储空间，但它也是最小和最昂贵的。远离CPU越远，存储设备的容量就越大，但离CPU也越远。这些设备的每GB值也会更便宜。</p>
<p><img src="https://img-blog.csdnimg.cn/e9b71ad365be4747aad97f721d926341.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<p><strong>Volatile Devices:</strong></p>
<ul>
<li>Volatile means that if you pull the power from the machine, then the data is lost.</li>
<li>Volatile storage supports fast random access with byte-addressable locations. This means that the program can jump to any byte address and get the data that is there.</li>
<li>For our purposes, we will always refer to this storage class as “memory”.</li>
</ul>
<p><strong>Non-Volatile Devices:</strong></p>
<ul>
<li>Non-volatile means that the storage device does not need to be provided continuous power in order for the device to retain the bits that it is storing.</li>
<li>It is also block/page addressable. This means that in order to read a value at a particular offset, the program first has to load the 4 KB page into memory that holds the value the program wants to read.</li>
<li>Non-volatile storage is <strong>traditionally better at sequential access</strong> (reading multiple chunks of data at the same time).</li>
<li>We will refer to this as “disk”. We will not make a (major) distinction between solid-state storage(SSD) or spinning hard drives (HDD).</li>
</ul>
<p>还有一种新的存储设备即将问世，称为非易失性存储器<strong>（non-volatile memory）</strong>。这些设备被设计成最好的两个世界：几乎和DRAM一样快，但具有磁盘的持久性。</p>
<p>由于系统假定数据库存储在磁盘上，因此DBMS的组件负责确定如何从非易失性磁盘和易失性存储器中来回移动数据，因为系统不能直接在磁盘上操作数据。</p>
<p>我们将关注如何隐藏磁盘的延迟，而不是使用寄存器和缓存的优化，<strong>因为从磁盘获取数据非常慢</strong>。如果从L1缓存引用中读取数据需要半秒，那么从SSD中读取需要1.7天，从HDD中读取需要16.5周。</p>
<h3 id="面向磁盘的DBMS概述"><a href="#面向磁盘的DBMS概述" class="headerlink" title="面向磁盘的DBMS概述"></a>面向磁盘的DBMS概述</h3><p>数据库均在磁盘上，数据库文件中的数据被组织成页面（page），第一个page是目录page。为了对数据进行操作，DBMS需要将数据加载到内存中，这一操作通过设置一个缓冲池，管理磁盘和内存之间数据的来回移动。DBMS还有一个可以执行查询的执行引擎。执行引擎向缓冲池申请特定的页面，缓冲池负责将该页面载入内存并为执行引擎分配一个指向内存中该页面的指针。当执行引擎对该内存地址进行操作时，缓冲池管理器确保需要的页面在这一位置。</p>
<h3 id="DBMS-vs-OS"><a href="#DBMS-vs-OS" class="headerlink" title="DBMS vs OS"></a>DBMS vs OS</h3><p>DBMS的一个高层次的设计目标是使得数据库能够使用的内存大小超过memory的大小。由于读写磁盘的成本高昂，因此必须仔细管理它。我们不希望从磁盘中读取数据时给系统中其他部分带来延迟，所以我们希望当系统等待从磁盘中取出数据时DBMS可以去处理其他的查询任务。</p>
<p>这一高层的设计目标有点类似于虚拟内存，虚拟内存具有较大的地址空间且支持操作系统从磁盘中加载页面。实现这种虚拟内存的一种方法是使用mmap在进程地址空间中映射文件的内容，这使得操作系统负责在磁盘和内存之间来回移动页面。不幸的是，这意味着如果mmap出现页面错误，这将阻止该进程。</p>
<ul>
<li>You never want to use mmap in your DBMS if you need to write.</li>
<li>The DBMS (almost) always wants to control things itself and can do a better job at it since it knows more about the data being accessed and the queries being processed. </li>
<li>The operating system is not your friend.</li>
</ul>
<p>对于复杂场景下的多个写任务可以通过以下方式进行优化：</p>
<ul>
<li>madvise：告诉操作系统知道你什么时候计划阅读某些页面</li>
<li>mlock：告诉操作系统不要将内存范围交换到磁盘</li>
<li>msync：告诉操作系统将内存范围刷新到磁盘</li>
</ul>
<font color=red>**We do not advise using mmap in a DBMS for correctness and performance reasons.**</font>

<p>尽管系统具有操作系统可以提供的功能，但让DBMS实现这些过程本身可以给它更好的控制和性能。</p>
<h3 id="File-Storage"><a href="#File-Storage" class="headerlink" title="File Storage"></a>File Storage</h3><p>一般DBMS将数据库作为文件存放在磁盘上，一些采用文件层次结构，一些使用单个文件（SQLite）。该操作系统并不知道这些文件的内容。只有DBMS知道如何解读它们的内容，因为它是以一种特定于DBMS的方式进行编码的。DBMS的存储管理器负责管理数据库的文件，其将文件表示为页面page的集合。它还可以跟踪已读取和写入页面的数据，以及页面中有多少空闲空间。</p>
<h3 id="Database-Pages"><a href="#Database-Pages" class="headerlink" title="Database Pages"></a>Database Pages</h3><p>DBMS通过一个或多个固定大小的数据块（page）组织数据库。页面可以包含不同类型的数据（元组、索引等)。大多数系统不会在页面中混合这些类型。有些系统要求页面包含读取页面内容所需的信息。</p>
<p>每个页面都有一个唯一的标识符DBMS。如果数据库是单个文件，那么页面id可以只是文件的偏移量。大多数DBMS都有一个间接层，它将页面id映射到文件路径和偏移量。系统的上层将要求提供一个特定的页号，然后存储管理器将必须将该页号转换为一个文件和一个偏移量来找到该页面。</p>
<p>大多数DBMS使用固定大小的页面，以避免支持可变大小的页面所需的工程开销。例如，对于可变大小的页面，删除一个页面可能会在文件中创建一个漏洞，而DBMS无法轻松填充新页面。</p>
<p><strong>DBMS中的页面有三个概念：</strong></p>
<ul>
<li>Hardware page (usually 4 KB).</li>
<li>OS page (4 KB).</li>
<li>Database page (1-16 KB).</li>
</ul>
<p>存储设备保证对硬件页面大小的原子写入。如果硬件页面为4KB，那么当系统试图将4KB写入磁盘时，要么写入所有4KB，要么不写入它们。这意味着，如果我们的数据库页面大于我们的硬件页面，DBMS将不得不采取额外的措施来确保数据安全写入，因为当系统崩溃时，程序可以通过将数据库页面写入磁盘。</p>
<h3 id="Database-Heap"><a href="#Database-Heap" class="headerlink" title="Database Heap"></a>Database Heap</h3><p>不同的DBMS在管理磁盘文件中的页时采用不同的方法：</p>
<ul>
<li>Heap File Organization</li>
<li>Sequential/Sorted File Organization</li>
<li>Hashing File Organization</li>
</ul>
<p>堆文件是页面的无序集合，其中元组以随机顺序存储。DBMS可以根据给定的page_id使用页面的链接列表或者页面目录在磁盘上定位页面。</p>
<ul>
<li><p><strong>Linked List：</strong></p>
<p>头页面保存指向空闲页面和数据页面的指针。但是，如果DBMS正在寻找一个特定的页面，那么它必须对数据页面列表进行连续扫描，直到找到它正在查找的页面。</p>
<p><img src="https://img-blog.csdnimg.cn/048cc815820a495aa947c2cdc6117cd2.png" alt="请添加图片描述" style="zoom:67%;" /></p>
</li>
<li><p><strong>Page Directory：</strong></p>
<p>DBMS维护一些特殊的页面，用来跟踪数据页面的位置以及每个页面上的空闲空间量。</p>
<p><img src="https://img-blog.csdnimg.cn/8e20188031804fdea5c6ebf542e274f9.png" alt="请添加图片描述" style="zoom:67%;" /></p>
</li>
</ul>
<h3 id="Page-Layout"><a href="#Page-Layout" class="headerlink" title="Page Layout"></a>Page Layout</h3><p>每一个页面都包含了一个头，其中保存了页面内容的元数据。</p>
<p><img src="https://img-blog.csdnimg.cn/0b7a020488904a6a9ea86ddba7920ca3.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<ul>
<li><p>Page Size</p>
</li>
<li><p>Checksum</p>
</li>
<li><p>DBMS Version</p>
</li>
<li><p>Transaction Visibility</p>
</li>
<li><p>Compression Information</p>
</li>
<li>Some systems require pages to be self-contained (oracle)</li>
</ul>
<p>关于如何在页面中存储元组，最简单的方法是<strong>Strawman Idea</strong>:记录页面中元组的数量并将新的元组添加至页面的末尾。但是当删除元组或者元组的长度不固定时存在缺陷。</p>
<p><img src="https://img-blog.csdnimg.cn/9ffac7a33fe541c3a43dacca5340e025.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<p>关于数据在页面中的存放方式主要有两种。</p>
<p><strong>slotted-pages</strong></p>
<ul>
<li>页面将插槽映射到偏移量。目前在DBMS中最常用的方法。</li>
<li>Header跟踪已使用的槽的数量以及最后使用的槽和一个槽阵列的起始位置的偏移量，它跟踪每个元组的起始位置。</li>
<li>要添加一个元组，插槽数组将从开始到端增长，而元组的数据将从端到开始增长。当插槽数组和元组数据满足时，该页面被认为是满的。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://img-blog.csdnimg.cn/3d454d2942ba4e3fadf1c07682476d84.png" alt="请添加图片描述" style="zoom:67%;" /></th>
<th style="text-align:center"><img src="https://img-blog.csdnimg.cn/fc2c5db394d64bf7a07cb1d425346de1.png" alt="请添加图片描述" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><strong>log-structured</strong></p>
<ul>
<li><p>不采用存储元组的方式，直接在page中存储日志记录。</p>
</li>
<li><p>将记录存储到修改数据库的文件（插入、更新、删除）。</p>
</li>
<li><p>如要读取记录，DBMS会向后扫描日志文件并“重新创建”元组。</p>
</li>
<li><p>快速写，可能读取较慢。</p>
</li>
<li><p>在仅附加存储上工作得很好，因为DBMS不能返回和更新数据。</p>
</li>
<li>为了避免长时间的读取，DBMS可以使用索引来允许它跳转到日志中的特定位置。它还可以定期压缩日志（如果它有一个元组，然后对其进行更新，它可以将其压缩到只插入更新后的元组）。压缩的问题是DBMS最终以写入放大（它一遍又一遍地重新包装相同的数据）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://img-blog.csdnimg.cn/48bd9c4074174224b695289bb12ecbf0.png" alt="请添加图片描述" style="zoom:67%;" /></th>
<th style="text-align:center"><img src="https://img-blog.csdnimg.cn/c6dc5b11eda74e52978028ef6f575e7d.png" alt="请添加图片描述" style="zoom:67%;" /></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Tuple-Layout"><a href="#Tuple-Layout" class="headerlink" title="Tuple Layout"></a>Tuple Layout</h3><p>一个元组本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。</p>
<p><img src="https://img-blog.csdnimg.cn/54043f31f7f248bbaa4ada87e908b104.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<p><strong>Tuple Header:</strong> 包含与该元组有关的元数据</p>
<ul>
<li>DBMS的并发控制协议的可见性信息（关于创建/修改该元组的事务的息）。</li>
<li>空值的位映射。</li>
<li>请注意，DBMS不需要在这里存储关于数据库模式的元数据。</li>
</ul>
<p><strong>Tuple Data:</strong> 各个属性的真实值</p>
<ul>
<li>属性通常按照您在创建表时指定属性的顺序存储。</li>
<li>大多数DBMS不允许一个元组超过一个页面的大小。</li>
</ul>
<p><strong>Unique Identifier:</strong>元组的惟一标识</p>
<ul>
<li>数据库中每一个元组都被分配了一个唯一标识</li>
<li>常见格式为：page_id+（offset or slot）</li>
<li>标识可能会动态变化，应用程序不能过度依赖</li>
</ul>
<p><strong>Denormalized Tuple Data</strong>：反正则化数据</p>
<p>如果有两个表是相关的，那么DBMS可以“预连接”它们，因此这些表最终会出现在同一页上。这使得读取速度更快，因为DBMS只需要加载一个页面，而不是两个单独的页面，但它使更新更加昂贵，因为DBMS为每个元组需要更多的空间。</p>
<h3 id="Data-Representation"><a href="#Data-Representation" class="headerlink" title="Data Representation"></a>Data Representation</h3><p>元组的数据本质上只是字节数组。由DBMS知道如何解释这些字节来导出属性的值。数据表示方案是DBMS如何存储一个值的字节。主要类型可以存储在元组中：整数、可变精度数、固定点精度数、可变长度值和日期/时间。</p>
<p><strong>Integers</strong></p>
<ul>
<li>大多数DBMS使用IEEE-754标准所指定的“本机”C/C++类型来存储整数。这些值是固定的长度；</li>
<li>例如：INTEGER, BIGINT, SMALLINT, TINYINT；</li>
</ul>
<p><strong>Variable Precision Numbers</strong></p>
<ul>
<li>使用IEEE-754标准指定的“本地”C/C++类型的不精确的、可变精度的数字类型。这些值也是固定的长度</li>
<li>可变精度数比任意精度数计算得更快，因为CPU可以直接在它们上执行指</li>
<li>例如: FLOAT, REAL</li>
</ul>
<p><strong>Fixed Point Precision Numbers</strong></p>
<ul>
<li>这些都是具有任意精度和规模的数字数据类型。它们通常以精确的、可变长度的二进制表示形式存储，而附加的元数据将告诉系统十进制应该在哪里。</li>
<li>当舍入错误不可接受时，将使用这些数据类型，但是DBMS会支付性能损失以获得这种精度。</li>
<li>例如：NUMERIC, DECIMAL</li>
</ul>
<p><strong>Variable Length Data</strong></p>
<ul>
<li>一个具有任意长度的字节数组。</li>
<li>有一个跟踪字符串长度的头，以便很容易跳转到下一个值。</li>
<li>大多数DBMS不允许元组超过单个页面的大小，因此它们通过在溢出页面上写入值，并使元组包含对该页面的引用来解决这个问题。</li>
<li>有些系统允许您将这些大值存储在外部文件中，然后元组将包含一个指向该文件的指针。例如，如果我们的数据库中存储了照片信息，那么我们就可以将照片存储在外部文件中，而不是让它们在DBMS中占用大量的空间。这样做的一个缺点是，DBMS无法操作该文件的内容</li>
<li>例如：VARCHAR, VARBINARY, TEXT, BLOB</li>
</ul>
<p><strong>Dates and Times</strong></p>
<ul>
<li>自从unix出现以来，通常都被表示为（微/毫）秒的数量</li>
<li>例如：TIME, DATE, TIMESTAMP</li>
</ul>
<h3 id="Workloads"><a href="#Workloads" class="headerlink" title="Workloads"></a>Workloads</h3><h4 id="OLTP-On-line-Transaction-Processing-在线事务处理"><a href="#OLTP-On-line-Transaction-Processing-在线事务处理" class="headerlink" title="OLTP: On-line Transaction Processing 在线事务处理"></a>OLTP: On-line Transaction Processing 在线事务处理</h4><ul>
<li>Fast, short running operations</li>
<li>Queries operate on single entity at a time</li>
<li>More writes than reads</li>
<li>Repetitive operations</li>
<li>Usually the kind of application that people build first</li>
<li>Example: User invocations of Amazon. They can add things to their cart, they can make purchases,but the actions only affect their account.</li>
</ul>
<h4 id="OLAP-On-line-Analyitical-Processing-在线分析处理"><a href="#OLAP-On-line-Analyitical-Processing-在线分析处理" class="headerlink" title="OLAP: On-line Analyitical Processing 在线分析处理"></a>OLAP: On-line Analyitical Processing 在线分析处理</h4><ul>
<li>Long running, more complex queries</li>
<li>Reads large portions of the database</li>
<li>Exploratory queries</li>
<li>Deriving new data from data collected on the OLTP side</li>
<li>Example: Compute the five most bought items over a one month period for these geographical locations</li>
</ul>
<h3 id="Storage-Models"><a href="#Storage-Models" class="headerlink" title="Storage Models"></a>Storage Models</h3><h4 id="N-Ary-Storage-Model-NSM"><a href="#N-Ary-Storage-Model-NSM" class="headerlink" title="N-Ary Storage Model (NSM)"></a>N-Ary Storage Model (NSM)</h4><p>DBMS连续地存储单个元组的所有属性，因此NSM也被称为“行存储”。这种方法非常适合于OLTP工作负载，在那里，事务往往只操作单个实体并插入大量的工作负载。它是理想的，因为它只需要一次获取就可以获得单个元组的所有属性。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>Fast inserts, updates, and deletes</p>
</li>
<li><p>Good for queries that need the entire tuple</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Not good for scanning large portions of the table and/or a subset of the attributes. This is because it pollutes the buffer pool by fetching data that is not needed for processing the query</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/0084166b6a494db98ecbb18b790882b8.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<p>两种组织NSM数据库的方式：</p>
<ul>
<li><p><strong>Heap-Organized Tables:</strong> 堆组织表</p>
<p>元组存储在称为堆的块中，并且堆不一定定义顺序。</p>
</li>
<li><p><strong>Index-Organized Tables：</strong>索引组织表</p>
<p>元组存储在主键索引本身中，但与聚集索引不同。</p>
</li>
</ul>
<h4 id="Decomposition-Storage-Model-DSM"><a href="#Decomposition-Storage-Model-DSM" class="headerlink" title="Decomposition Storage Model (DSM)"></a>Decomposition Storage Model (DSM)</h4><p>DBMS在一个数据块中连续存储所有元组的单个属性（列）。也被称为“列式存储”。这个模型非常适合于OLAP工作负载，在这些工作负载中，只读查询对表的属性子集执行大型扫描。</p>
<p><img src="https://img-blog.csdnimg.cn/ff581a9a029e4a4a83f8cb4f1b40b793.png" alt="请添加图片描述" style="zoom:67%;" /></p>
<p><strong>优点：</strong></p>
<ul>
<li>减少了在查询执行过程中浪费的工作量，因为DBMS只读取该查询所需的数据。</li>
<li>支持更好的压缩，因为相同属性的所有值都是连续存储的。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>由于元组被拆分/拼接，导致点查询、插入、更新和删除的速度较慢。</li>
</ul>
<p>当我们使用列存储时，为了将元组放在一起，我们可以使用：</p>
<ul>
<li><p><strong>Fixed-length offsets</strong>：</p>
<p>首先，假设这些属性都是固定长度的。然后，当系统想要一个特定元组的属性时，它就知道如何跳转到文件中的那个位置。为了适应可变长度的字段，系统可以填充它们，使它们都是相同的长度，或者您可以使用一个固定大小的整数并将整数映射到值。</p>
</li>
<li><p><strong>Embedded Tuple Ids</strong>:</p>
<p>对于列中的每个属性，都要使用其来存储元组id。系统还需要额外的信息来告诉它如何跳转到具有该id的每个属性。</p>
</li>
</ul>
<p>大多数DBMS使用固定长度的偏移量。</p>
<font color=red>**Row stores are usually better for OLTP, while column stores ar better for OLAP.**</font>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Smartog</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/14/cmu445-3/">http://example.com/2022/07/14/cmu445-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">扶摇之鹏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/database-system/">database system</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/ShareJS/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/16/cmu445-4/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">cmu445-4 Buffer Pools</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/13/cmu445-2/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">cmu14-445 2 Advanced SQL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/12/cmu445-1/" title="cmu 14-445 1 relational model"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">cmu 14-445 1 relational model</div></div></a></div><div><a href="/2022/07/13/cmu445-2/" title="cmu14-445 2 Advanced SQL"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">cmu14-445 2 Advanced SQL</div></div></a></div><div><a href="/2022/07/16/cmu445-4/" title="cmu445-4 Buffer Pools"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-16</div><div class="title">cmu445-4 Buffer Pools</div></div></a></div><div><a href="/2022/07/18/cmu445-hash_table/" title="cmu445-5 Hash Table"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-18</div><div class="title">cmu445-5 Hash Table</div></div></a></div><div><a href="/2022/07/19/cmu445-Tree-Indexes/" title="cmu445-6 Tree Indexes"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-19</div><div class="title">cmu445-6 Tree Indexes</div></div></a></div><div><a href="/2022/07/21/cmu15-445-IndexConcurrency/" title="cmu15-445_IndexConcurrency"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-21</div><div class="title">cmu15-445_IndexConcurrency</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">1.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%A3%81%E7%9B%98%E7%9A%84DBMS%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">面向磁盘的DBMS概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DBMS-vs-OS"><span class="toc-number">3.</span> <span class="toc-text">DBMS vs OS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Storage"><span class="toc-number">4.</span> <span class="toc-text">File Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Database-Pages"><span class="toc-number">5.</span> <span class="toc-text">Database Pages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Database-Heap"><span class="toc-number">6.</span> <span class="toc-text">Database Heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Layout"><span class="toc-number">7.</span> <span class="toc-text">Page Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tuple-Layout"><span class="toc-number">8.</span> <span class="toc-text">Tuple Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Representation"><span class="toc-number">9.</span> <span class="toc-text">Data Representation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Workloads"><span class="toc-number">10.</span> <span class="toc-text">Workloads</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OLTP-On-line-Transaction-Processing-%E5%9C%A8%E7%BA%BF%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">OLTP: On-line Transaction Processing 在线事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OLAP-On-line-Analyitical-Processing-%E5%9C%A8%E7%BA%BF%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">OLAP: On-line Analyitical Processing 在线分析处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage-Models"><span class="toc-number">11.</span> <span class="toc-text">Storage Models</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#N-Ary-Storage-Model-NSM"><span class="toc-number">11.1.</span> <span class="toc-text">N-Ary Storage Model (NSM)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decomposition-Storage-Model-DSM"><span class="toc-number">11.2.</span> <span class="toc-text">Decomposition Storage Model (DSM)</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Smartog</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = '/pluginsSrc/mathjax/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="/pluginsSrc/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>