<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>cmu445_Timestamp_Ordering_Concurrency_Control | 扶摇之鹏</title><meta name="keywords" content="database system"><meta name="author" content="Smartog,2369398685@qq.com"><meta name="copyright" content="Smartog"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="上节课介绍的 2PL 是悲观的并发控制策略，本节课介绍的 Timestamp Ordering (T&#x2F;O) 则是一个乐观的策略，其乐观表现在事务访问数据时无需显式加锁。T&#x2F;O 的核心思想就是利用时间戳来决定事务之间的等价执行顺序： 如果 TS(T_i)">
<meta property="og:type" content="article">
<meta property="og:title" content="cmu445_Timestamp_Ordering_Concurrency_Control">
<meta property="og:url" content="http://example.com/2022/07/24/cmu445-Timestamp-Ordering-Concurrency-Control/index.html">
<meta property="og:site_name" content="扶摇之鹏">
<meta property="og:description" content="上节课介绍的 2PL 是悲观的并发控制策略，本节课介绍的 Timestamp Ordering (T&#x2F;O) 则是一个乐观的策略，其乐观表现在事务访问数据时无需显式加锁。T&#x2F;O 的核心思想就是利用时间戳来决定事务之间的等价执行顺序： 如果 TS(T_i)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png">
<meta property="article:published_time" content="2022-07-24T01:49:03.000Z">
<meta property="article:modified_time" content="2022-07-24T08:56:03.944Z">
<meta property="article:author" content="Smartog">
<meta property="article:tag" content="database system">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/24/cmu445-Timestamp-Ordering-Concurrency-Control/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cmu445_Timestamp_Ordering_Concurrency_Control',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-24 16:56:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img-blog.csdnimg.cn/8f7b645dd13642308f79801772084d7c.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">扶摇之鹏</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">cmu445_Timestamp_Ordering_Concurrency_Control</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-24T01:49:03.000Z" title="发表于 2022-07-24 09:49:03">2022-07-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-24T08:56:03.944Z" title="更新于 2022-07-24 16:56:03">2022-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cmu15-445/">cmu15-445</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cmu445_Timestamp_Ordering_Concurrency_Control"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>上节课介绍的 2PL 是悲观的并发控制策略，本节课介绍的 Timestamp Ordering (T/O) 则是一个乐观的策略，其乐观表现在事务访问数据时无需显式加锁。T/O 的核心思想就是利用时间戳来决定事务之间的等价执行顺序：</p>
<p><strong>如果 <script type="math/tex">TS(T_i)<TS(T_j)</script> ，那么数据库必须保证实际的 schedule 与先执行<script type="math/tex">T_i</script>  ，后执行 <script type="math/tex">T_j</script>的结果等价。</strong></p>
<p>要实现 T/O，就需要一个单调递增的时钟，来决定任意事务 <script type="math/tex">T_i</script>发生的时间。满足条件的时钟方案有很多，如：</p>
<ul>
<li><p>系统单调时钟 (System Clock)</p>
</li>
<li><p>逻辑计数器 (Logical Counter)</p>
</li>
<li><p>混合方案 (Hybrid)</p>
</li>
</ul>
<h3 id="Basic-T-O"><a href="#Basic-T-O" class="headerlink" title="Basic T/O"></a>Basic T/O</h3><p>Basic T/O 是 T/O 方案的一种具体实现。在 Basic T/O 中，事务读写数据不需要加锁，每条数据 X 都会携带两个标记：</p>
<ul>
<li><strong>W-TS(X)：</strong>最后一次写X发生的<strong>时间戳</strong>；</li>
<li><strong>R-TS(X)：</strong>最后一次读X发生的<strong>时间戳</strong>；</li>
</ul>
<p>在每个事务结束时，Basic T/O 需要检查该事务中的每个操作，是否读取或写入了未来的数据，一旦发现则中止、重启事务。</p>
<ul>
<li><p><strong>Basic T/O Reads</strong></p>
<p>读取数据时的逻辑如下所示：如果事务<script type="math/tex">T_i</script>发生在 W-TS(X) 之前，即尝试读取未来的数据，则中止<script type="math/tex">T_i</script>。如果事务 <script type="math/tex">T_i</script>发生在 W-TS(X) 之后，意味着它正在读取过去的数据，符合规范。读取数据后，如果有必要，则更新 R-TS(X)，同时保留一份 X 的副本，用来保证<script type="math/tex">T_i</script>结束之前总是能读到相同的 X。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">read</span><span class="params">(X)</span> val </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">TS</span><span class="params">(T_i)</span> &lt; <span class="title">W_TS</span><span class="params">(X)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">abort_and_restart</span>(T_i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val := <span class="built_in">read_data</span>(X)</span><br><span class="line">        <span class="built_in">R_TS</span>(X) = <span class="built_in">max</span>(<span class="built_in">R_TS</span>(X), <span class="built_in">TS</span>(T_i))</span><br><span class="line">        <span class="comment">// make a local copy of X to ensure repeatable reads for T_i</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Basic T/O Writes</strong></p>
<p>写入数据时的逻辑如下所示：如果事务 <script type="math/tex">T_i</script> 发生在 W-TS(X) 或 R-TS(X) 之前，即尝试写入已经被未来的事务读取或写入的数据，则中止<script type="math/tex">T_i</script>；反之，意味着它正尝试修改过去的数据，符合规范。<script type="math/tex">T_i</script>写入数据后，如果有必要，则更新 W-TS(X)，同时保留一份 X 的副本，用来保证<script type="math/tex">T_i</script>结束之前总是能读到相同的 X。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">write</span><span class="params">(X, val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">TS</span><span class="params">(T_i)</span> &lt; <span class="title">R_TS</span><span class="params">(X)</span> || <span class="title">TS</span><span class="params">(T_i)</span> &lt; <span class="title">W_TS</span><span class="params">(X)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">abort_and_restart</span>(T_i)        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        X = val</span><br><span class="line">        <span class="built_in">W_TS</span>(X) = <span class="built_in">max</span>(<span class="built_in">W_TS</span>(X), <span class="built_in">TS</span>(T_i))</span><br><span class="line">        <span class="comment">// make a local copy of X to ensure repeatable reads for T_i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Basic T/O - Example #1</strong></p>
<p>如下图所示：有两个事务<script type="math/tex">T_1</script>和<script type="math/tex">T_2</script>，它们的时间戳分别为 1，2，即 <script type="math/tex">T_1</script>发生在<script type="math/tex">T_2</script>之前，它们要访问的数据为 A 和 B，假设它们是数据库预填充的数据，R-TS 和 W-TS 都为 0。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6Zwtc_I2QvCFDHbaqA%2FScreen%20Shot%202020-05-05%20at%209.08.10%20PM.jpg?alt=media&token=b71a8bda-42ea-43d2-9fee-5a1b44629971" alt="img" style="zoom:33%;" /></p>
<ul>
<li><p><script type="math/tex">T_1</script>先读取 B，将 R-TS(B) 更新为 1</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6ZxczB5UKKXHKcrQ1e%2FScreen%20Shot%202020-05-05%20at%209.11.26%20PM.jpg?alt=media&token=a9d7b37d-4c9e-404a-98f9-4b44b2af58c2" alt="img" style="zoom:33%;" /></p>
</li>
<li><p><script type="math/tex">T_2</script>读取 B，将 R-TS(B) 更新为 2</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6Zy7Fv78oZcMF3Tsb3%2FScreen%20Shot%202020-05-05%20at%209.13.36%20PM.jpg?alt=media&token=79b1bbfa-f202-475e-b4ba-7fd651f89fde" alt="img" style="zoom:33%;" /></p>
</li>
<li><p><script type="math/tex">T_2</script>修改 B，将 W-TS(B) 更新为 2</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6ZyL5f8CTfhuctGBzF%2FScreen%20Shot%202020-05-05%20at%209.14.33%20PM.jpg?alt=media&token=27d93384-8dfc-4b10-9073-7a74419b5410" alt="img" style="zoom:33%;" /></p>
</li>
<li><p><script type="math/tex">T_1</script>读取 A，将 W-TS(A) 更新为 1</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6ZyXDLfqih9fExaowc%2FScreen%20Shot%202020-05-05%20at%209.15.23%20PM.jpg?alt=media&token=67b32bd0-2ae7-4d6e-b003-4297efbe9329" alt="img" style="zoom:33%;" /></p>
</li>
<li><p><script type="math/tex">T_2</script>读取 A，将 R-TS(A) 更新为 2</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6Zykqkj3FQhAX-SFGh%2FScreen%20Shot%202020-05-05%20at%209.16.16%20PM.jpg?alt=media&token=2f9925db-79b6-4e40-ab85-dd0723cd64a9" alt="img" style="zoom:33%;" /></p>
</li>
<li><p><script type="math/tex">T_2</script>修改 A，将 W-TS(A) 更新为 2</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6Zwe94QImOVU_Kp7rn%2F-M6ZzAHq_nRO1_qSH3vb%2FScreen%20Shot%202020-05-05%20at%209.18.11%20PM.jpg?alt=media&token=3eec7b5e-a6ce-4ddd-a8d5-cb0795b0eb52" alt="img" style="zoom:33%;" /></p>
<p>由于整个过程，没有发生违背规范的操作，因此两个事务都能够成功提交。</p>
</li>
</ul>
<p><strong>Basic T/O - Example #2</strong></p>
<p>类似地，我们可以看下面这个例子：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6ZzTQZrGE4NimMiwGa%2F-M6ZziUUevVBlwVVbXuI%2FScreen%20Shot%202020-05-05%20at%209.20.29%20PM.jpg?alt=media&token=bd5b207e-ca9c-4d35-aa73-8a8c551a6800" alt="img" style="zoom:33%;" /></p>
<p>不难看出， <script type="math/tex">T_1</script>在<script type="math/tex">T_2</script>修改 A 后又修改了 A，覆盖了来自未来的数据，该操作肯定会违反规范：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6ZzTQZrGE4NimMiwGa%2F-M6_-M11zzcazJjaV8R6%2FScreen%20Shot%202020-05-05%20at%209.23.21%20PM.jpg?alt=media&token=22e44b5b-0740-4377-b7e8-a26e31e3ebd0" alt="img" style="zoom:33%;" /></p>
<p>因此<script type="math/tex">T_1</script>将被数据库中止。但实际上，仔细分析上述例子，如果我们忽略掉 <script type="math/tex">T_1</script>的 W(A) 操作，即不更新 A 数据，也不修改 W-TS(A)，那么<script type="math/tex">T_1</script>和 都<script type="math/tex">T_2</script>可以正常提交，且结果和二者先后执行等价，这便是所谓的 Thomas Write Rule (TWR)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">write</span><span class="params">(X, val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">TS</span><span class="params">(T_i)</span> &lt; <span class="title">R_TS</span><span class="params">(X)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">abort_and_restart</span>(T_i)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">TS</span>(T_i) &lt; <span class="built_in">W_TS</span>(X) &#123;</span><br><span class="line">        <span class="comment">// ignore write</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    X = val</span><br><span class="line">    <span class="built_in">W_TS</span>(X) = <span class="built_in">TS</span>(T_i)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>example #2 符合 TWR，可以允许让两个事务顺利提交。TWR 优化了 Basic T/O 的写检查，使得一些本不必中止的事务顺利进行，提高了事务并发程度。</p>
<p><strong>Basic T/O Summary</strong></p>
<p>如果不使用 TWR 优化，Basic T/O 能够生成 conflict serializable 的 schedule，如果使用了 TWR，则 Basic T/O 生成的 schedule 虽然与顺序执行的效果相同，但不满足 conflict serializable。</p>
<p>Basic T/O 的优势在于：</p>
<ul>
<li>不会造成死锁，因为没有事务需要等待；</li>
<li>如果单个事务涉及的数据不多、不同事务涉及的数据基本不相同 (OLTP)，可以节省 2PL 中控制锁的额外成本，提高事务并发度；</li>
</ul>
<p>缺点在于：</p>
<ul>
<li><p>长事务容易因为与短事务冲突而饿死</p>
</li>
<li><p>复制数据，维护、更新时间戳存在额外成本</p>
</li>
<li><p>可能产生不可恢复的 schedule (具体见下节)</p>
</li>
</ul>
<p><strong>Recoverable Schedules</strong></p>
<p>如果一个 schedule 能够保证每个事务提交前，修改过其读取过数据的事务都已提交，那么这个 schedule 就是 recoverable。如果不能保证 recoverable，DBMS 就无法在发生崩溃之后恢复数据，举例如下：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6ZzTQZrGE4NimMiwGa%2F-M6_5GfoyGaTRZ0ZwS2y%2FScreen%20Shot%202020-05-05%20at%209.49.01%20PM.jpg?alt=media&token=ee646fb3-ea64-43e5-90c6-e0a1284871bc" alt="img" style="zoom:33%;" /></p>
<p><script type="math/tex">T_2</script>在 <script type="math/tex">T_1</script>修改 A 之后读取 A，符合规范。但是在<script type="math/tex">T_2</script>提交之后，<script type="math/tex">T_1</script>中止，前者依赖的数据实际上并未真实写入，数据库发生故障以后将无法恢复。因此 Basic T/O 可能产生不可恢复的 schedules。</p>
<h3 id="Optimistic-Concurrency-Control-OCC"><a href="#Optimistic-Concurrency-Control-OCC" class="headerlink" title="Optimistic Concurrency Control (OCC)"></a>Optimistic Concurrency Control (OCC)</h3><p>OCC 是 H.T. KUNG 在 CMU 任教时提出的并发控制算法。在 OCC 中，数据库为每个事务都创建一个私有空间：</p>
<ul>
<li><p>所有被读取的数据都复制到私有空间中</p>
</li>
<li><p>所有修改都在私有空间中执行</p>
</li>
</ul>
<p>OCC 分为 3 个阶段：</p>
<ul>
<li><p><strong>Read Phase：</strong>追踪、记录每个事务的读、写集合，并存储到私有空间中</p>
</li>
<li><p><strong>Validation Phase：</strong>当事务提交时，检查冲突</p>
</li>
<li><p><strong>Write Phase：</strong>如果校验成功，则合并数据；否则中止并重启事务</p>
</li>
</ul>
<p>DBMS 需要维持所有活跃事务的全局视角，并将 Validation Phase 和 Write Phase 的逻辑放入一个 critical section 中。</p>
<p><strong>OCC - Example</strong></p>
<p>事务<script type="math/tex">T_1</script>读取 A 时，将 A 复制到自己的 workspace 中，可以看到，与 Basic T/O 相比，OCC 只需要记录一个时间戳，W-TS。</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_76Ga6vY8sOz2YjAs%2F-M6_D0_x9XY1MMO80mKf%2FScreen%20Shot%202020-05-05%20at%2010.22.46%20PM.jpg?alt=media&token=7ab08868-f059-4140-8206-908243e38995" alt="img" style="zoom: 33%;" /></p>
<p>事务 <script type="math/tex">T_2</script> 读取 A 时，同样将 A 复制到自己的 workspace 中：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_76Ga6vY8sOz2YjAs%2F-M6_DBFiW7iNOBFrzdMc%2FScreen%20Shot%202020-05-05%20at%2010.23.47%20PM.jpg?alt=media&token=323c8fc6-472e-4cf1-9c6e-9fabe3509528" alt="img" style="zoom: 25%;" /></p>
<p>事务<script type="math/tex">T_2</script>完成数据操作，在 Validation Phase 中获得事务时间戳 1，由于没有数据写入，跳过 Write Phase:</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_76Ga6vY8sOz2YjAs%2F-M6_DhPRivTWFqbwdvzA%2FScreen%20Shot%202020-05-05%20at%2010.26.01%20PM.jpg?alt=media&token=76fc9375-b20c-4a6b-b8c8-1b58b8aaeae9" alt="img" style="zoom: 25%;" /></p>
<p>事务<script type="math/tex">T_1</script>修改 A 的值为 456，由于尚不知道自己的事务时间戳，将 W-TS(A) 设置为无穷大：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_76Ga6vY8sOz2YjAs%2F-M6_EE9X3ntezhC4IgFZ%2FScreen%20Shot%202020-05-05%20at%2010.28.11%20PM.jpg?alt=media&token=17452402-ea4b-4577-b638-cfc613ce241c" alt="img" style="zoom:25%;" /></p>
<p>事务<script type="math/tex">T_1</script>在 Validation Phase 获得事务时间戳 2，并通过校验，将 W-TS(A) 修改为 2，并合并到数据库中:</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_76Ga6vY8sOz2YjAs%2F-M6_Ec13pXWulHBsq5A-%2FScreen%20Shot%202020-05-05%20at%2010.29.59%20PM.jpg?alt=media&token=d8aabc8b-7e07-4592-8791-f925186c6076" alt="img" style="zoom:25%;" /></p>
<h4 id="OCC-Read-Phase"><a href="#OCC-Read-Phase" class="headerlink" title="OCC-Read Phase"></a>OCC-Read Phase</h4><p>追踪事务的读写集合 (read/write sets)，将 read set 存放在 private workspace 中用来保证 repeatable read，将 write set 存放在 private workspace 中用来作冲突检测。</p>
<h4 id="OCC-Validation-Phase"><a href="#OCC-Validation-Phase" class="headerlink" title="OCC-Validation Phase"></a>OCC-Validation Phase</h4><p>在进入 Validation Phase 后，每个事务都会被赋予一个时间戳，然后与其它正在运行的事务执行 Timestamp Ordering 检查，检查的方式有两种：</p>
<ul>
<li><p>Backward Validation</p>
</li>
<li><p>Forward Validation</p>
</li>
</ul>
<p>如下图所示，在 Backward Validation 中，需要检查待提交的事务 (txn #2) 的读写集合是否与已经提交的事务的读写集合存在交集：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_H1IGb81n16B2BNts%2F-M6_T2bw-o0csVEWsN7q%2FScreen%20Shot%202020-05-05%20at%2011.32.54%20PM.jpg?alt=media&token=aada6e52-c62b-40eb-98ec-6953e24b0ace" alt="img" style="zoom:25%;" /></p>
<p>与此类似，在 Forward Validation 中，需要检查待提交的事务 (txn #2) 的读写集合是否与尚未提交的事务的读写集合存在交集：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_H1IGb81n16B2BNts%2F-M6_TdUqGgudKTrMu6WW%2FScreen%20Shot%202020-05-05%20at%2011.35.41%20PM.jpg?alt=media&token=6a0cad2e-dd0f-4138-aa91-f7c6cfe43d16" alt="img" style="zoom:25%;" /></p>
<p><strong>如果<script type="math/tex">TS(T_i)<TS(T_j)</script>,那么以下3个条件之一必须成立：</strong></p>
<ul>
<li><p><strong>Condition 1：</strong> <script type="math/tex">T_i</script> completes all three phases before <script type="math/tex">T_j</script> begins；</p>
<p>如果事务<script type="math/tex">T_i</script>在事务<script type="math/tex">T_j</script>开始之j前已经完成 OCC 的所有 3 个阶段，那么二者之间不存在任何冲突。</p>
</li>
<li><p><strong>Condition 2:  <script type="math/tex">T_i</script> </strong>completes before <script type="math/tex">T_j</script> starts its  Write Phase, and <script type="math/tex">T_i</script>  does not write to any object read by <script type="math/tex">T_j</script> ；</p>
<p>如果 <script type="math/tex">T_i</script>在 <script type="math/tex">T_j</script>的 Write Phase 开始前j就已提交，同时<script type="math/tex">T_i</script>没j有修改任意 <script type="math/tex">T_j</script>读取的数据，则二者之间不存在冲突。</p>
</li>
<li><p><strong>Condition 3:</strong>  <script type="math/tex">T_i</script> completes its <strong>Read Phase</strong> before <script type="math/tex">T_j</script> completes its Read Phase, and <script type="math/tex">T_i</script> does not write to any object that is either read or written by <script type="math/tex">T_j</script>；</p>
<p>如果 <script type="math/tex">T_i</script> 在<script type="math/tex">T_j</script>  结束自己的 Read Phase 前结束 Read Phase，同时<script type="math/tex">T_i</script> 没有修改任何 <script type="math/tex">T_j</script> 读取或修改的数据，二者之间不存在冲突。</p>
</li>
</ul>
<p>OCC 与 Basic T/O 的思路类似，都是在检查事务之间的 WW、WR 冲突。当冲突发生的频率很低时，即：</p>
<ul>
<li>大部分事务都是读事务</li>
<li>大部分事务之间访问的数据间没有交集</li>
</ul>
<p>OCC 的表现很好，如在数据库体量较大，workload 比较均衡的场景下。2PC 的性能瓶颈在于锁管理，<strong>尽管 OCC 没有加锁的成本，但它也存在性能问题:</strong></p>
<ul>
<li>在 private workspace 与 global database 之间移动、合并数据开销大；</li>
<li>Validation/Write Phase 需要在一个全局的 critical section 中完成，可能造成瓶颈；</li>
<li>在 Validation Phase 中，待提交事务需要和其它事务做冲突检查，即便实际上并没有冲突，这里也有很多获取 latch 的成本 (锁住其它事务的 private workspace，对比是否有冲突，再释放锁)；</li>
<li>事务中止的成本比 2PL 高，因为 OCC 在事务执行快结束时才检查数据冲突；</li>
</ul>
<h3 id="Partition-Based-T-O"><a href="#Partition-Based-T-O" class="headerlink" title="Partition-Based T/O"></a>Partition-Based T/O</h3><p>类似全局锁到分段锁的优化，我们也可以将数据库切分成不相交 (disjoint) 的子集，即 horizontal partitions 或 shards，然后在 partition 内部使用单调递增的时间戳确定各个事务的顺序，不同 partition 上的事务之间无需检测冲突。</p>
<p>假设数据库中存储着如下三张表：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bP7olcpabplPw0_Fs%2FScreen%20Shot%202020-05-06%20at%208.35.10%20AM.jpg?alt=media&token=b01fa045-5cd4-4aeb-8906-167fb8609c43" alt="img" style="zoom: 25%;" /></p>
<p>我们可以按照 customer 的 c_id 对数据库分片：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bPUzcaOty-52fcvD2%2FScreen%20Shot%202020-05-06%20at%208.36.48%20AM.jpg?alt=media&token=5bac91dd-c7d3-4652-a8d4-7ed1b265789a" alt="img" style="zoom: 25%;" /></p>
<p>每个 partition 使用一个锁保护：</p>
<ul>
<li><p>当事务需要访问多个 partitions 时，就在所需的多个 partitions 上排队</p>
</li>
<li><p>如果事务的时间戳是整个 partition 中最小的，那么该事务就获得锁</p>
</li>
<li><p>当事务获取其所需访问的所有 partitions 的全部锁，它就可以开始执行</p>
</li>
</ul>
<p><strong>Partition-Based T/O - Reads</strong>：</p>
<p>如果事务已经获取分片上的锁，该事务就能够读取它想读取的任意数据。如果事务尝试访问一个未获取锁的分片，那么它将被中止后重启。</p>
<p><strong>Partition-Based T/O - Writes</strong>：</p>
<p>写事务直接在原地修改数据，并在内存中维护一个缓冲区，用来记录修改的数据以便事务中止后回滚。如果事务尝试修改一个未获取锁的分片，那么它将被中止后重启。</p>
<p><strong>Partition-Based T/O - Example</strong>：</p>
<p>假设有两个事务同时开启，并分别被分配了全局的时间戳 100 和 101，二者都需要获取 partition 1 上的锁，如下图所示：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bS2dKC2LulpNZXzhU%2FScreen%20Shot%202020-05-06%20at%208.47.44%20AM.jpg?alt=media&token=c9274635-2048-49b2-85f9-13d06370392c" alt="img" style="zoom: 25%;" /></p>
<p>由于事务 #100 的时间戳较小，它将获得 partition 1 的锁，从而执行事务</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bTnU1apO6j-AAEOrE%2FScreen%20Shot%202020-05-06%20at%208.55.36%20AM.jpg?alt=media&token=a5ddc32a-0894-4304-819b-8f069fb85305" alt="img" style="zoom:25%;" /></p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bTuL1But7EmZfKgxY%2FScreen%20Shot%202020-05-06%20at%208.56.00%20AM.jpg?alt=media&token=f2edb6e8-ff8f-49cd-b9ff-1e268caaa5ae" alt="img" style="zoom:25%;" /></p>
<p>随后事务 #101 才能够n获得 partition 1 的锁，执行事务内容</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6_auaKtEsF2_XWdPAa%2F-M6bU7iJDgXMdUTvqth_%2FScreen%20Shot%202020-05-06%20at%208.56.32%20AM.jpg?alt=media&token=9a9305ab-ec7a-439f-b029-84a248babeb0" alt="img" style="zoom:25%;" /></p>
<p>Partition-based T/O 的性能取决于以下两点：</p>
<ul>
<li><p>DBMS 是否在事务开启前就能知道事务所需的所有 partitions</p>
</li>
<li><p>是否大多数事务只需要访问单个 partition</p>
</li>
</ul>
<p>multi-partition 的事务将使得更多其它事务陷入等待状态，取了锁而未使用的 partition 也可能陷入空转。</p>
<h3 id="Dynamic-Databases"><a href="#Dynamic-Databases" class="headerlink" title="Dynamic Databases"></a>Dynamic Databases</h3><p>到现在为止，我们都只考虑事务读取和更新数据，如果我们再考虑插入、删除操作，就会遇到新的问题。</p>
<p><strong>The Phantom Problem</strong></p>
<p>考虑插入操作，则可能出现 Phantom Read：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6bVPQhjyYFe1KQ6GHy%2F-M6bff0_ruU0fexpEFBs%2FScreen%20Shot%202020-05-06%20at%209.51.50%20AM.jpg?alt=media&token=b1c0888c-6a8a-4be9-9c05-595c367b86c6" alt="img" style="zoom:25%;" /></p>
<p><strong>即在单个事务内部，同样的查询，读到不一样的数据</strong>。这种现象发生的原因在于，<strong>尽管<script type="math/tex">T_1</script> 锁住了已经存在的记录，但新生成的记录并不会被锁住</strong>，因此实际上 <strong>conflict serializability 能保证事务可序列化的前提是数据集合是固定的</strong>，出现记录新增和删除时，这个结论就不成立了。</p>
<p><strong>Predicate Locking</strong></p>
<p>predicate locking 指的是通过一个逻辑表达式来为潜在的记录加锁，如：<code>status = &#39;lit&#39;</code> 。然而，predicate locking 的成本很高，对每条新插入的数据都需要做校验。基本没有 DBMS 用这种方式实现，一种更高效的做法是 index locking。</p>
<p><strong>Index Locking</strong></p>
<p>同样以上文中的例子为例，如果在 <code>status</code> 字段上有索引，那么我们可以锁住满足 <code>status = &#39;lit&#39;</code> 的 index page，如果尚未存在这样的 index page，我们也需要能够找到可能对应的 index page，锁住它们。</p>
<p><strong>Locking Without An Index</strong></p>
<p>同样以上文中的例子为例，如果在 <code>status</code> 字段上没有索引，那么事务就需要执行以下操作：</p>
<ul>
<li><p>获取 table 的每个 page 上的锁，防止其它记录的 <code>status</code> 被修改成 <code>lit</code> </p>
</li>
<li><p>获取 table 本身的锁，防止满足 <code>status = &#39;lit&#39;</code> 的记录被插入或删除</p>
</li>
</ul>
<p><strong>Repeating Scans</strong></p>
<p>另一种比较暴力的做法是在事务提交时，扫描 <code>status = &#39;lit&#39;</code> 的所有数据，检查这些数据是否与事务操作之前的数据相同。目前没有任何商业数据库采用这种方案。</p>
<h3 id="Isolation-Level"><a href="#Isolation-Level" class="headerlink" title="Isolation Level"></a>Isolation Level</h3><p>以上讨论的都是可序列化的并发控制方案。可序列化固然是一种很实用的特性，它可以将程序员从并发问题中解脱，但可序列化的方案要求比较严格，会对系统的并发度和性能造成较大的限制，因此<strong>我们也许能够用更弱的数据一致性保证去改善系统的扩展性</strong>。<strong>这也是所谓的数据库隔离级别。</strong></p>
<p>更弱的数据库隔离级别将事务修改的数据暴露给其它事务，以此提高整体并发度，但这种并发度可能造成一系列问题，如 Dirty Reads/Writes (脏读、脏写)、Unrepeatable Reads (不可重复读)、Phantom Reads (幻读) 等等。</p>
<p>常见的数据库隔离级别从弱到强依次包括：Read Uncommitted -&gt; Read Committed -&gt; Repeatable Reads -&gt; Serializable，总结如下表：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6eRCI41LheZVY_A298%2F-M6eTkwLavFpb6-ZmB3y%2FScreen%20Shot%202020-05-06%20at%2010.54.15%20PM.jpg?alt=media&token=f0599bba-438c-48a5-a49c-1fa6665dc18d" alt="img" style="zoom:33%;" /></p>
<p>该表总结得不太完全，更详细的讨论可参考 <a href="">Transactions</a>。</p>
<p><strong>SQL - 92 Isolation Levels</strong></p>
<p>SQL-92 中定义了数据库设置隔离级别的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL <span class="operator">&lt;</span>isolation<span class="operator">-</span>level<span class="operator">&gt;</span>;   <span class="operator">/</span><span class="operator">/</span> 全局设定</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION ISOLATION LEVEL <span class="operator">&lt;</span>isolation<span class="operator">-</span>level<span class="operator">&gt;</span>; <span class="operator">/</span><span class="operator">/</span> 单事务设定</span><br></pre></td></tr></table></figure>
<p>但并非所有数据库在所有运行环境中都能支持所有隔离级别，且数据库的默认隔离级别取决于它的实现。以下是 2013 年统计的一些数据库的默认隔离级别和最高隔离级别：</p>
<p><img src="https://2836672763-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-LMjQD5UezC9P8miypMG%2F-M6eRCI41LheZVY_A298%2F-M6eVZQL0_-w21gGAAqo%2FScreen%20Shot%202020-05-06%20at%2011.02.10%20PM.jpg?alt=media&token=166c04f7-66ae-4800-a64f-b7fdf223d871" alt="img" style="zoom:33%;" /></p>
<p><strong>SQL-92 Access Mode</strong></p>
<p>SQL-92 中也允许用户提示数据库自己的事务是否会修改数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION <span class="operator">&lt;</span>access<span class="operator">-</span>mode<span class="operator">&gt;</span>;   <span class="operator">/</span><span class="operator">/</span> 全局设置</span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION <span class="operator">&lt;</span>access<span class="operator">-</span>mode<span class="operator">&gt;</span>; <span class="operator">/</span><span class="operator">/</span> 单个事务设置</span><br></pre></td></tr></table></figure>
<p>其中 access-mode 有两种模式：READ WRITE 和 READ ONLY。当然，即便在 SQL 语句中添加了这种提示，也不是所有数据库都会利用它来优化 SQL 语句的执行。</p>
<p>转载：<a target="_blank" rel="noopener" href="https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/timestamp-ordering-concurrency-control">https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/timestamp-ordering-concurrency-control</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Smartog</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/24/cmu445-Timestamp-Ordering-Concurrency-Control/">http://example.com/2022/07/24/cmu445-Timestamp-Ordering-Concurrency-Control/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">扶摇之鹏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/database-system/">database system</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/ShareJS/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/ShareJS/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/9732abb7d2ec4ba09cba5cf29507e04f.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" target="_blank"><img class="post-qr-code-img" src="https://img-blog.csdnimg.cn/899038c3a02c4a14925da419444eb3a4.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/24/cmu445-Multiversion-Concurrency-Control/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">cmu445_Multiversion_Concurrency_Control</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/24/cmu445-Two-Phase-Locking/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">cmu445_Two_Phase_Locking</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/12/cmu445-1/" title="cmu 14-445 1 relational model"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">cmu 14-445 1 relational model</div></div></a></div><div><a href="/2022/07/13/cmu445-2/" title="cmu14-445 2 Advanced SQL"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">cmu14-445 2 Advanced SQL</div></div></a></div><div><a href="/2022/07/14/cmu445-3/" title="cmu15-445-3 Data Storage"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-14</div><div class="title">cmu15-445-3 Data Storage</div></div></a></div><div><a href="/2022/07/16/cmu445-4/" title="cmu445-4 Buffer Pools"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-16</div><div class="title">cmu445-4 Buffer Pools</div></div></a></div><div><a href="/2022/07/18/cmu445-hash_table/" title="cmu445-5 Hash Table"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-18</div><div class="title">cmu445-5 Hash Table</div></div></a></div><div><a href="/2022/07/19/cmu445-Tree-Indexes/" title="cmu445-6 Tree Indexes"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-19</div><div class="title">cmu445-6 Tree Indexes</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-T-O"><span class="toc-number">1.</span> <span class="toc-text">Basic T&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimistic-Concurrency-Control-OCC"><span class="toc-number">2.</span> <span class="toc-text">Optimistic Concurrency Control (OCC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OCC-Read-Phase"><span class="toc-number">2.1.</span> <span class="toc-text">OCC-Read Phase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OCC-Validation-Phase"><span class="toc-number">2.2.</span> <span class="toc-text">OCC-Validation Phase</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partition-Based-T-O"><span class="toc-number">3.</span> <span class="toc-text">Partition-Based T&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Databases"><span class="toc-number">4.</span> <span class="toc-text">Dynamic Databases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolation-Level"><span class="toc-number">5.</span> <span class="toc-text">Isolation Level</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Smartog</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = '/pluginsSrc/mathjax/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="/pluginsSrc/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>